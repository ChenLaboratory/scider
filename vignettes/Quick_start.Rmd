---
title: "A quick start guide to the scider package"
author: "Ning Liu, Mengbo Li, Yunshun Chen"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cosmo
    highlight: tango
    code_folding: show
vignette: >
  %\VignetteIndexEntry{scider_introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">
  body{
  font-size: 14pt;
}
</style>

```{r message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, dpi = 72, fig.retina = 1)
suppressWarnings(library(ggplot2))
```

# Installation

```{r eval=FALSE}
if (!require("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

BiocManager::install("scider")
```

The development version of `scider` can be installed from GitHub:

```{r eval=FALSE}
devtools::install_github("ChenLaboratory/scider")
```

# Quick start

```{r}
library(scider)
library(SpatialExperiment)
library(patchwork)
```


# Load data

In this vignette, we will use a subset of a Xenium Breast Cancer dataset.

```{r}
data("xenium_bc_spe")
```

In the data, we have quantification of 541 genes from 185211 cells.

```{r}
spe
```

We also have cell-type annotations of these cells, there are 4 cell types.

```{r}
table(colData(spe)$cell_type)
```

We can use the function `plotSpatial` to visualise the cell position and color the cells by cell types.

```{r, fig.width=4, fig.height=3}
plotSpatial(spe, color = cell_type, alpha = 0.8)
```

We can also visualise the cell type one by one.

```{r}

p1 <- plotSpatial(spe, color = cell_type == "Fibroblasts", alpha = 0.6) +
  theme(legend.position = "none") +
  ggtitle("Fibroblasts")
p2 <- plotSpatial(spe, color = cell_type == "Breast cancer", alpha = 0.6) +
  theme(legend.position = "none") +
  ggtitle("Breast cancer")
p3 <- plotSpatial(spe, color = cell_type == "T cells", alpha = 0.6) +
  theme(legend.position = "none") +
  ggtitle("T cells")
p4 <- plotSpatial(spe, color = cell_type == "B cells", alpha = 0.6) +
  theme(legend.position = "none") +
  ggtitle("B cells")
```


```{r, fig.width=5, fig.height=5}
wrap_plots(list(p1,p2,p3,p4), ncol = 2, nrow = 2)
```

# Grid-based analysis

`scider` can conduct grid-based density analysis for spatial transcriptomics data.

## Density calculation

Before calculating density, we need to define cell type-of-interest (COI).
In this case, all cell types are COIs.

```{r}
coi <- unique(colData(spe)$cell_type)
coi
```

We can perform density calculation for each COI using function `gridDensity`.
The calculated density and grid information are saved in the metadata of the SpatialExperimnet object.

```{r}
spe <- gridDensity(spe, coi = coi)

names(spe@metadata)
```

```{r}
spe@metadata$grid_density
```

We can visualise the density of each COI using function `plotDensity`.

```{r}
pd_list <- list()
for(i in seq(4)){
  pd_list[[i]] <- plotDensity(spe, coi = coi[i])
}

```


```{r, fig.width=6, fig.height=5}
wrap_plots(pd_list, ncol = 2, nrow = 2)
```

## Find Regions-of-interest (ROIs)

After obtaining grid-based density for each COI, we can then detect regions-of-interest (ROIs) based on density or select by user.

### Detected by algorithm

To detect ROIs automatically, we can use the function `findROI`.

The detected ROIs are saved in the metadat of the SpatialExperiment object.

```{r}
spe <- findROI(spe, coi = coi)

spe@metadata$roi
```

We can visualise the ROIs with function `plotROI`.

```{r, fig.width=4, fig.height=4}
plotROI(spe)
```

### Select ROI by user

Alternatively, users can select ROIs based on their own research interest (drawn by hand).
This can be done using function `selectRegion`.
This function will open an interactive window with an interactive plot for users to zoom-in/-out and select ROI using either a rectangular or lasso selection tool. Users can also press the `Export selected points` button to save the ROIs as object in the R environment.

```{r, eval=FALSE}
selectRegion(spe@metadata$grid_density, x.col = "x_grid", y.col = "y_grid")
```

After closing the interactive window, the selected ROI has been saved as a data.frame object named `sel_region` in the R environment.

```{r, eval=FALSE}
sel_region
```

We can then use the `postSelRegion` to save the ROI in the metadata of the SpatialExperiment object.

```{r, eval=FALSE}
spe1 <- postSelRegion(spe, sel_region = sel_region)

spe1@metadata$roi
```

Similarly, we can plot visualise the user-defined ROI with function `plotROI`.

```{r, eval=FALSE}
plotROI(spe1)
```

## Testing relationship between cell types

After defining ROIs, we can then test the relationship between any two cell types within each ROI or overall but account for ROI variation using a cubic spline or a linear fit.

This can be done with function `corrDensity`, by setting the `celltype1` and `celltype2` parameters, the modelling results are saved in the metadata of the SpatialExperiment object.


```{r}
model_result <- corDensity(spe)
```

We can see the correlation between breast cancer and fibroblasts in each ROI.

```{r}
model_result
```

We can also visualise the fitting using function `plotDensCor`.

```{r}
plotDensCor(spe, celltype1 = "Breast cancer", celltype2 = "Fibroblasts")
```

Or, we can visualise the statistics between cell types using function `plotModStat` with a heatmap.


```{r}
plotCorHeatmap(model_result)
```



```{r}
model_result2 <- corDensity(spe, by.roi = FALSE)

plotCorHeatmap(model_result2)
```


# Cell-based analysis

Based on the grid density, we can ask many biological question about the data. For example, we would like to know if a certain cell type that are located in high density of breast cancer cells are different to the same cell type from a different level of breast cancer region.

## cell annotation based on grid density

To address this question, we first need to divide cells into different levels of grid density. This can be done using a contour identification strategy with function `getContour`.


```{r}
spe <- getContour(spe, coi = "Breast cancer")
```

Different level of contour can be visualised with cells using `plotContour`.

```{r}
plotContour(spe, coi = "Breast cancer")
```

Or with density using parameter `overlay = "density"`.

```{r}
plotContour(spe, coi = "Breast cancer", overlay = "density")
```

Or we can subset on specific density level with parameter `sub.level`.


```{r}
plotContour(spe, coi = "Breast cancer", 
            sub.level = "1")
```


We can then annotate cells by their locations within each contour using function `allocateCells`.


```{r}
spe <- allocateCells(spe)
```


```{r}
plotSpatial(spe, color = cell_type == "Breast cancer") +
  scale_color_manual(values = c("gray", "red"))
```


```{r}
plotSpatial(spe, color = breast_cancer_contour, alpha = 0.5) +
  scale_color_manual(values = rev(RColorBrewer::brewer.pal(11, "Spectral")))
```

We can visualise cell type composition per level.

```{r}
plotCellCompo(spe, coi = "Breast cancer")
```


```{r}
plotCellCompo(spe, coi = "Breast cancer", by.roi = TRUE)
```






















